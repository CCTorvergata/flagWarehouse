import logging

import math
import os
import os.path
import subprocess

import requests


def run_exploit(exploit: str, ip: str, round_duration: int, server_url: str, token: str, pattern, user: str):
    def timer_out(process):
        timer.cancel()
        process.kill()

    p = subprocess.Popen(
        [exploit, ip], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    timer = Timer(math.ceil(0.5 * round_duration), timer_out, args=[p])

    timer.start()
    while True:
        output = p.stdout.readline().decode().strip()
        if output == '' and p.poll() is not None:
            break
        if output:
            logging.debug(f'{os.path.basename(exploit)}@{ip} => {output}')
            flags = set(pattern.findall(output))
            if flags:
                exp = exploit.split('/')[-1][:-3]
                logging.info(f'Got {GREEN}{len(flags)}{END} flags with {BLUE}{exp}{END} from {ip}')
                msg = {'username': user, 'flags': []}
                t_stamp = datetime.now().replace(microsecond=0).isoformat(sep=' ')
                for flag in flags:
                    msg['flags'].append({'flag': flag,
                                         'exploit_name': os.path.basename(exploit),
                                         'team_ip': ip,
                                         'time': t_stamp})
                requests.post(server_url + '/api/upload_flags',
                              headers = {'X-Auth-Token': token},
                              json = msg)
    p.stdout.close()
    return_code = p.poll()
    timer.cancel()
    if return_code == -9:
        logging.error(f'{RED}{os.path.basename(exploit)}{END}@{ip} was killed because it took too long to finish')
    elif return_code != 0:
        logging.error(f'{RED}{os.path.basename(exploit)}{END}@{ip} terminated with error code {HIGH_RED}{return_code}{END}')


def load_exploits(exploit_directory):
    try:
        scripts = [os.path.join(exploit_directory, s) for s in os.listdir(exploit_directory) if
            os.path.isfile(os.path.join(exploit_directory, s)) and not s.startswith('.')]

        # Fix non executable
        for s in scripts:
            if not os.access(s, os.X_OK):
                os.chmod(s, 0o755)
                logging.warning(f'{os.path.basename(s)} is not executable, giving permission to execute...')

        for s in scripts:
            with open(s, 'r+', encoding='utf-8') as f:
                lines = f.readlines()
                if lines[0] != '#!/usr/bin/env python3\n':
                    lines.insert(0, '#!/usr/bin/env python3\n')
                    f.seek(0, 0)
                    f.writelines(lines)
                    f.close()
                    logging.warning(f'{os.path.basename(s)} no shebang #!, adding it...')


    except FileNotFoundError:
        logging.error('The directory specified does not exist.')
        logging.info('Exiting...')
        sys.exit(0)
    except PermissionError:
        logging.error('You do not have the necessary permissions to use this directory.')
        logging.info('Exiting')
        sys.exit(0)

    return scripts